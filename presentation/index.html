<!doctype html>
<html lang="en">

<head>
	<meta charset="utf-8">
	<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">

	<title>Performancetesting mit Microsoft Azure Load Testing</title>

	<link rel="stylesheet" href="dist/reset.css">
	<link rel="stylesheet" href="dist/reveal.css">
	<link rel="stylesheet" href="dist/theme/black.css">
	<link rel="stylesheet" href="css/reveal-override.css" />

	<link rel="stylesheet" href="plugin/highlight/monokai.css">
</head>

<body>
	<div class="watermark">
		<a href="https://www.qytera.de/" rel="noopener noreferrer">
			<img src="images/qytera-logo.png" />
		</a>
	</div>
	<div class="reveal">
		<div class="slides">
			<section>
				<h2>Performancetesting mit Microsoft Azure Load Testing</h2>
				<img src="images/azure-load-testing.png" alt="Azure" style="width:40%">
				<aside class="notes">
					Hallo und herzlich willkommen auch von mir. Danke Markus fÃ¼r die Einleitung. Ich freue mich, dass
					ihr heute hier seid und ich euch ein wenig Ã¼ber das Thema Performancetesting mit Microsoft Azure
					Load Testing erzÃ¤hlen darf.
				</aside>
			</section>
			<section>
				<h2>Agenda ğŸ“‹</h2>
				<ul>
					<li>kurze Vorstellung</li>
					<li>Performance-Testing</li>
					<li>Apache JMeter</li>
					<ul>
						<li>Web-Applikation testen</li>
						<li>JMeter skalieren</li>
					</ul>
					<li>Azure Load Testing</li>
					<ul>
						<li>Architektur</li>
						<li>Kosten</li>
						<li>Hands-On</li>
						<li>Azure DevOps Pipelines</li>
					</ul>
					<li>Fazit</li>
				</ul>
				<aside class="notes">
					ZunÃ¤chst werde ich mich kurz vorstellen und dann in das Thema einsteigen. Ich werde euch zeigen, wie
					Apache JMeter grundsÃ¤tzlich funktioniert. Ich werde dabei nicht auf high-sophisticated Features
					eingehen, sondern nur auf wenige Basics. Gerade ausreichend um eine kleine Web-App damit testen zu
					kÃ¶nnen. AnschlieÃŸend werde ich euch Microsoft Azure Load Testing vorstellen und euch zeigen wie
					Azure Load Testing aufgebaut ist und wie man damit JMeters Skalierbarkeit zu nutze machen kann.
					Dabei werde ich direkt mit Azure Load Testing arbeiten und euch Hands-On Einblicke geben.
					AbschlieÃŸend werde ich euch zeigen, man diese Performancetests dann in eine Azure DevOps Pipeline
					integrieren kann um die Tests automatisiert und regelmÃ¤ÃŸig durchzufÃ¼hren.
				</aside>
			</section>
			<section>
				<section>
					<h2>Der Sprecher ğŸ™Š</h2>
					<figure>
						<img src="images/profil.png" alt="Matthias Eggert" style="width:40%">
						<figcaption>Matthias Eggert</figcaption>
					</figure>
					<aside class="notes">
						Ich bin DevOps-Engineer mit einer umfangreichen Expertise in der
						Automobilbranche, wo ich mich tiefgehend mit der Entwicklung sicherheitsrelevanter Funktionen
						fÃ¼r Bremssysteme und Batteriemanagementsysteme beschÃ¤ftigt habe. Derzeit arbeite ich bei der
						Qytera GmbH als DevOps-Engineer und widme mich vor allem der Testautomatisierung mit modernen
						Tools, sowohl in der Cloud als auch darÃ¼ber hinaus. Ich habe einen Master of Science in Visual
						Computing von der Technischen UniversitÃ¤t Darmstadt und einen Bachelor in Computervisualistik
						von der Otto-von-Guericke-UniversitÃ¤t Magdeburg. Meine Karriere fÃ¼hrte mich in den letzten 11
						Jahren zu renommierten Unternehmen wie Continental und Marquardt, wo ich bedeutende BeitrÃ¤ge in
						den Bereichen Entwicklung, Softwareintegration und insbesondere Automatisierung geleistet habe.
						Ich bin also mit einer umfangreichen Expertise in der Automobilbranche ausgestattet, wo ich mich
						tiefgehend mit der Entwicklung sicherheitsrelevanter Funktionen fÃ¼r Bremssysteme und
						Batteriemanagementsysteme beschÃ¤ftigt habe; im Besonderen mit der Optimierung der Entwicklung
						und der automatischen und kontinuierlichen Integration und Bereitstellung (CI/CD). Als AWS
						Certified Cloud Practitioner und mit einer ISTQB FL Zertifizierung ausgestattet, bin ich hier
						bei Qytera fÃ¼r die Performance-Tests zustÃ¤ndig.
					</aside>
				</section>
			</section>
			<section>
				<section>
					<h2>Performance-Testing â±ï¸</h2>
					<ul>
						<li>Warum?</li>
						<li>Wann?</li>
						<li>Wie?</li>
					</ul>
					<aside class="notes">
						Performance-Tests sind ein entscheidender Aspekt der Softwareentwicklung, der sicherstellt, dass
						eine Anwendung nicht nur die funktionalen Anforderungen erfÃ¼llt, sondern auch in Bezug auf
						Geschwindigkeit, StabilitÃ¤t und Skalierbarkeit unter verschiedenen Bedingungen leistungsfÃ¤hig
						ist.
						Bevor wir uns dem spezifischen Thema Azure Load Testing zuwenden, ist es wichtig, einen
						Ãœberblick
						Ã¼ber das Konzept des Performance-Testings zu geben.
					</aside>
				</section>
				<section>
					<h2>Performance-Testing Arten ğŸ‹ï¸ğŸ§˜ğŸš£ğŸƒ</h2>
					<img src="images/performance-tests-types.png" alt="Performance-Testing Arten" class="r-stretch">
					<aside class="notes">
						Performance-Tests umfassen verschiedene Testarten, darunter Lasttests, Stress-Tests und
						Ausdauer-
						oder Dauertests. Jede dieser Testarten zielt darauf ab, unterschiedliche Leistungsaspekte
						einer Anwendung zu bewerten. Zum Beispiel:

						- Lasttests simulieren eine typische Nutzerbelastung, um zu sehen, wie die Anwendung unter
						normalen
						Bedingungen funktioniert.
						- Stress-Tests erhÃ¶hen die Belastung schrittweise Ã¼ber das normale Niveau hinaus, um die Grenzen
						der
						Anwendung zu finden.
						- KapazitÃ¤ts-Tests gehen mit Absicht Ã¼ber die Grenzen der Anwendung hinaus, um zu sehen, wie sie
						scheitert.
						- Ausdauer-Tests prÃ¼fen die Anwendung auf ihre FÃ¤higkeit, Ã¼ber einen langen Zeitraum unter
						erwarteter Belastung zuverlÃ¤ssig zu funktionieren.

						Durch Performance-Tests kÃ¶nnen wir EngpÃ¤sse identifizieren, die Leistung optimieren und
						sicherstellen, dass unsere Anwendung auch unter Spitzenlast oder bei steigender Nutzerzahl
						zuverlÃ¤ssig funktioniert. Mit diesem grundlegenden VerstÃ¤ndnis von Performance-Tests kÃ¶nnen wir
						nun
						einen spezifischeren Blick auf Apache Jmeter werfen und verstehen, wie es uns unterstÃ¼tzt,
						unsere Anwendungen zu testen.
					</aside>
				</section>
			</section>
			<section>
				<section>
					<h2>Apache JMeter ğŸª¶</h2>
					<ul>
						<li>Open Source</li>
						<li>Java basiert</li>
						<li>GUI und CLI</li>
						<li>Skalierbar</li>
						<li>Plugins</li>
					</ul>
					<span class="videoTrigger" data-video-src="videos/workspaceEnvs.mp4">ğŸ¦</span>
					<aside class="notes">
						Apache JMeter ist ein mÃ¤chtiges Open-Source-Tool, das vorwiegend fÃ¼r Performance-Tests und
						Lasttests von Anwendungen eingesetzt wird. Entwickelt in Java, bietet JMeter eine flexible
						Plattform fÃ¼r die Bewertung der Leistung von Webanwendungen.

						JMeter kann sowohl Ã¼ber eine grafische BenutzeroberflÃ¤che (GUI) als auch Ã¼ber die
						Kommandozeilenschnittstelle (CLI) bedient zu werden. WÃ¤hrend die GUI insbesondere wÃ¤hrend der
						Testentwicklungsphase fÃ¼r ihre Benutzerfreundlichkeit und visuelle RÃ¼ckmeldung geschÃ¤tzt wird,
						ermÃ¶glicht die CLI einen effizienteren Betrieb in Testumgebungen, was besonders bei der
						Integration in CI/CD-Pipelines nÃ¼tzlich ist. Oder eben auch fÃ¼r eine Integration in
						Cloud-LÃ¶sungen wie Azure Load Testing. Wir haben es auch in einer eigenen cloud-basierten
						LasttestlÃ¶sung im Einsatz, QLoad.

						JMeter zeichnet sich durch seine Skalierbarkeit aus. Es kann auf einzelnen Workstations fÃ¼r
						einfache Testaufgaben eingesetzt werden, lÃ¤sst sich aber auch in groÃŸem Umfang fÃ¼r komplexe
						Lasttests verwenden, die mehrere Server umfassen kÃ¶nnen. Diese Skalierbarkeit macht es zu einem
						idealen Werkzeug fÃ¼r Unternehmen jeder GrÃ¶ÃŸe, um die Leistung ihrer Anwendungen unter
						verschiedenen Lastbedingungen zu bewerten.

						Ein weiteres wichtiges Merkmal von JMeter sind die zahlreichen verfÃ¼gbaren Plugins, die seine
						FunktionalitÃ¤t erweitern. Diese Plugins ermÃ¶glichen es den Benutzern, neue TestfÃ¤higkeiten
						hinzuzufÃ¼gen, die Anpassung von Berichten zu verbessern und die Integration mit anderen Tools
						und Plattformen zu vereinfachen. Obwohl JMeter bereits eine umfassende Palette an
						TestmÃ¶glichkeiten bietet, erlauben es diese Plugins, das Tool noch weiter an spezifische
						BedÃ¼rfnisse anzupassen. Die Entwicklung eigener Plugins ist ebenfalls mÃ¶glich, was die
						FlexibilitÃ¤t von JMeter zusÃ¤tzlich erhÃ¶ht.

						Insgesamt bietet Apache JMeter als ein vielseitiges, leistungsstarkes Tool fÃ¼r
						Performance-Testing und Lasttesting eine robuste LÃ¶sung fÃ¼r Entwickler und
						QualitÃ¤tssicherungs-Teams. Seine Open-Source-Natur, gepaart mit umfangreicher Dokumentation und
						einer aktiven Community, macht es zu einer zugÃ¤nglichen und wertvollen Ressource fÃ¼r die
						Optimierung der Leistung von Webanwendungen und anderen Diensten.
					</aside>
				</section>
				<section>
					<h2>Web-Applikation testen ğŸŒ</h2>
					<ul>
						<li>HTTP Request</li>
						<li>Response Times</li>
					</ul>
					<aside class="notes">
						Schauen wir uns nun an, wie wir mit JMeter eine einfache Web-Applikation testen kÃ¶nnen. Dazu
						verwenden wir eine einfache Flask-App, die wir auf einem Azure Web App Service bereitstellen.
						Diese App hat nur eine einzige Route, die wir mit einem Parameter aufrufen kÃ¶nnen, um eine
						bestimmte Zeit zu warten. Das ist nÃ¼tzlich, um die Reaktionszeit der Anwendung zu testen.
						und dadurch eine Art Last-Szenario zu simulieren. Wir tun also so, als ob viele Benutzer auf
						diese Route zugreifen und die Anwendung dadurch unter Last steht und langsamer wird. Wir
						werden sehen, wie wir mit JMeter eine solche Last erzeugen und die Reaktionszeiten messen
						kÃ¶nnen.
					</aside>
				</section>
				<section>
					<pre class="r-stretch">
						<code data-trim data-noescape data-line-numbers="1-18|8-12">
							from flask import Flask, request
							import time

							app = Flask(__name__)

							@app.route('/')
							def hello():
								# Retrieve the 'sleep' parameter from the URL
								sleep_time = float(request.args.get('sleep', 0))
								
								# Introduce a delay based on the sleep_time value
								time.sleep(sleep_time / 1000)

								return f"Slept for {sleep_time} milli seconds."


							if __name__ == '__main__':
								app.run(host='0.0.0.0', port=80)
						</code>
					</pre>
					<br>
					<a href="https://qyterawebapp.azurewebsites.net/?sleep=2000" target="_blank">Open App ğŸ</a>
					<span class="videoTrigger" data-video-src="videos/workspaceEnvs.mp4">ğŸ¦</span>
				</section>
				<section>
					<h2>JMeter skalieren âš–ï¸</h2>
					<img class="r-stretch" src="images/jmeter-controller-worker.png" alt="JMeter">
				</section>
			</section>
			<section>
				<section data-background-gradient="linear-gradient(to bottom, black 50%, white 100%)">
					<h2>Azure Load Testing ğŸ§ª</h2>
					<ul>
						<li>Cloud basiert --> kein Know-How von Infrastruktur oder IaC benÃ¶tigt</li>
						<li>Skalierbar</li>
						<li>integrierte Analyse-Werkzeuge, daher kein Wissen Ã¼ber Time-Series DBs oder Grafana notwendig
						</li>
						<ul>
							<li>Monitoring des Targets</li>
							<li>und der eigenen Lastagenten</li>
						</ul>
						<li>Integration in Azure DevOps</li>
					</ul>
				</section>
				<section data-background-color="white">
					<h2>Architektur ğŸ›ï¸ğŸ›•</h2>
					<img class="r-stretch" src="images/cloud-performance-testing.png" alt="Azure Load Testing">
				</section>
				<section data-background-gradient="linear-gradient(to bottom, white 0, black 50%)">
					<h2>Facts $ Money ğŸ¤‘</h2>
					<ul>
						<li>bis zu 100.000 virtuelle User sind mÃ¶glich</li>
						<li>$0,15 pro VUH (Virtual User Hour), ab 9950 VUH nur noch $0,075</li>
						<ul>
							<li>1.000 User * 1 Stunde = 150â‚¬</li>
							<li>10.000 User * 2 Stunde = 1.500â‚¬</li>
						</ul>
					</ul>
				</section>
				<section>
					<h2>Hands-On ğŸ‘</h2>
					<ul>
						<li>Erstellung eines Tests</li>
						<li>Skalierung</li>
						<li>Monitoring</li>
					</ul>
					<span class="videoTrigger" data-video-src="videos/workspaceEnvs.mp4">ğŸ¦</span>
				</section>
				<section>
					<h2>Einbindung in Azure DevOps Pipelines ğŸ”—</h2>
					<img src="images/pipeline.png" alt="Azure DevOps Pipeline" class="r-stretch">
					<span class="videoTrigger" data-video-src="videos/workspaceEnvs.mp4">ğŸ¦</span>
				</section>
			</section>
			<section>
				<h2>Fazit ğŸ©»</h2>
				<ul>
					<li>Apache JMeter ist mÃ¤chtig</li>
					<li>Microsoft Azure Load Testing ist eine gute ErgÃ¤nzung</li>
					<li>Azure DevOps macht das Setup komplett</li>
				</ul>
			</section>
		</div>
	</div>

	<script src="dist/reveal.js"></script>
	<script src="plugin/notes/notes.js"></script>
	<script src="plugin/markdown/markdown.js"></script>
	<script src="plugin/highlight/highlight.js"></script>
	<script src="plugin/video-popup/video-popup.js"></script>
	<script>
		Reveal.initialize({
			slideNumber: 'c/t',
			hash: true,
			plugins: [RevealHighlight, RevealNotes]
		});
	</script>
</body>

</html>