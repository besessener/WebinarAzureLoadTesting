<!doctype html>
<html lang="en">

<head>
	<meta charset="utf-8">
	<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">

	<title>Performancetesting mit Microsoft Azure Load Testing</title>

	<link rel="stylesheet" href="dist/reset.css">
	<link rel="stylesheet" href="dist/reveal.css">
	<link rel="stylesheet" href="dist/theme/black.css">
	<link rel="stylesheet" href="css/reveal-override.css" />
	<link rel="stylesheet" href="plugin/pointer/pointer.css" />

	<link rel="stylesheet" href="plugin/highlight/monokai.css">
</head>

<body>
	<div class="watermark">
		<a href="https://www.qytera.de/" rel="noopener noreferrer">
			<img src="images/qytera-logo.png" />
		</a>
	</div>
	<div class="reveal">
		<div class="slides">
			<section>
				<h2>Performancetesting mit Microsoft Azure Load Testing</h2>
				<img src="images/azure-load-testing.png" alt="Azure" style="width:40%">
				<aside class="notes">
					Hallo und herzlich willkommen auch von mir. Danke Markus fÃ¼r die Einleitung. Ich freue mich, dass
					ihr heute hier seid und ich euch ein wenig Ã¼ber das Thema Performancetesting mit Microsoft Azure
					Load Testing erzÃ¤hlen darf.
				</aside>
			</section>
			<section>
				<h2>Agenda ğŸ“‹</h2>
				<ul>
					<li>kurze Vorstellung</li>
					<li>Performance-Testing</li>
					<li>Apache JMeter</li>
					<ul>
						<li>Web-Applikation testen</li>
						<li>JMeter skalieren</li>
					</ul>
					<li>Azure Load Testing</li>
					<ul>
						<li>Architektur</li>
						<li>Kosten</li>
						<li>Hands-On</li>
						<li>Azure DevOps Pipelines</li>
					</ul>
					<li>Fazit</li>
				</ul>
				<aside class="notes">
					ZunÃ¤chst werde ich mich kurz vorstellen und dann in das Thema einsteigen. Ich werde euch zeigen, wie
					Apache JMeter grundsÃ¤tzlich funktioniert. Ich werde dabei nicht auf high-sophisticated Features
					eingehen, sondern nur auf wenige Basics. Gerade ausreichend um eine kleine Web-App damit testen zu
					kÃ¶nnen. AnschlieÃŸend werde ich euch Microsoft Azure Load Testing vorstellen und euch zeigen wie
					Azure Load Testing aufgebaut ist und wie man damit JMeters Skalierbarkeit zu nutze machen kann.
					Dabei werde ich direkt mit Azure Load Testing arbeiten und euch Hands-On Einblicke geben.
					AbschlieÃŸend werde ich euch zeigen, man diese Performancetests dann in eine Azure DevOps Pipeline
					integrieren kann um die Tests automatisiert und regelmÃ¤ÃŸig durchzufÃ¼hren.
				</aside>
			</section>
			<section>
				<section>
					<h2>Der Sprecher ğŸ™Š</h2>
					<figure>
						<img src="images/profil.png" alt="Matthias Eggert" style="width:40%">
						<figcaption>Matthias Eggert</figcaption>
					</figure>
					<aside class="notes">
						Meine Karriere fÃ¼hrte mich in den letzten 11
						Jahren zu renommierten Unternehmen wie Continental und Marquardt, wo ich bedeutende BeitrÃ¤ge in
						den Bereichen Entwicklung, Softwareintegration und insbesondere Automatisierung geleistet habe.
						Ich bin also mit einer umfangreichen Expertise in der Automobilbranche ausgestattet, wo ich mich
						tiefgehend mit der Entwicklung sicherheitsrelevanter Funktionen fÃ¼r Bremssysteme und
						Batteriemanagementsysteme beschÃ¤ftigt habe; im Besonderen mit der Optimierung der Entwicklung
						und der automatischen und kontinuierlichen Integration und Bereitstellung (CI/CD). Als AWS
						Certified Cloud Practitioner und mit einer ISTQB FL Zertifizierung ausgestattet, bin ich hier
						bei Qytera als DevOps-Engineer tÃ¤tig. Und im Zusammenhang Software Testing dann ganz speziell
						verantwortlich fÃ¼r die Performance-Tests.
					</aside>
				</section>
			</section>
			<section>
				<section>
					<h2>Performance-Testing â±ï¸</h2>
					<ul>
						<li>Warum?</li>
						<li>Wie?</li>
						<li>Wann?</li>
					</ul>
					<aside class="notes">
						Performance-Tests sind ein entscheidender Aspekt der Softwareentwicklung, der sicherstellt, dass
						eine Anwendung nicht nur die funktionalen Anforderungen erfÃ¼llt, sondern auch in Bezug auf
						Geschwindigkeit, StabilitÃ¤t und Skalierbarkeit unter verschiedenen Bedingungen leistungsfÃ¤hig
						ist. Bevor wir uns dem spezifischen Thema Azure Load Testing zuwenden, ist es wichtig, einen
						Ãœberblick Ã¼ber das Konzept des Performance-Testings zu geben.
					</aside>
				</section>
				<section>
					<h2>Super App ğŸ¦¸</h2>
					Demo: <a href="super-app/homepage.htm" target="_blank">Qytera Homepage</a>
					<aside class="notes">
						Bevor wir hier richtig tief reingehen erst einmal Werbung in eigener Sache. Wir bei Qytera haben
						eine super App entwickelt, die
						alle eure Probleme lÃ¶st. Sie ist schnell, stabil und skalierbar. Und weil wir sie so super
						finden haben wir sie auch "Super App" genannt. Die zeige ich euch jetzt mal schnell. Die App ist
						heute ganz frisch auf unserer Website verÃ¶ffentlicht worden. Wir haben ein paar AnkÃ¼ndigungen
						dazu gemacht auf den Ã¼blichen KanÃ¤len, aber ihr seid die ersten denen sie jetzt live vorgefÃ¼hrt
						wird.
					</aside>
				</section>
				<section>
					<h2>Darum ğŸ˜‡</h2>
					<span class="videoTrigger" data-video-src="videos/cat.mp4">ğŸ¦</span>
					<aside class="notes">
						Sollte so etwas heute tatsÃ¤chlich passieren, dann habe ich Backup Videos vorbereitet. Die sind
						alle in der PrÃ¤sentation enthalten. Also keine Sorge, wir kÃ¶nnen trotzdem weitermachen. Aber ich
						hoffe natÃ¼rlich, dass das nicht passiert.

						Ansonsten hatte ich ja gerade die Frage gezeigt: Warum Ã¼berhaupt Performance Tests? Und das kann
						ich jetzt mit einem Augenzwinkern beantworten. Stellt euch vor ihr entwickelt tatsÃ¤chlich eine
						super coole neue App. Eine wirklich disruptive App, die das Potential hat den Markt zu
						verÃ¤ndern. Die App wird verteilt und es kommen deutlich mehr Leute auf die Seite als zu
						handhaben ist. Dann wird ganz schnell aus der besten App der Welt das hier:
				</section>
				<section>
					<h1>ğŸ’©</h1>
					<aside class="notes">
						Um das zu verhindern, machen wir Performance Tests. Wir wollen sicherstellen, dass unsere
						Anwendung auch unter Last stabil und schnell bleibt. Wir wollen EngpÃ¤sse identifizieren, bevor
						sie zu einem Problem werden. Wir wollen sicherstellen, dass unsere Anwendung auch unter
						verschiedenen Bedingungen zuverlÃ¤ssig funktioniert. Und wir wollen sicherstellen, dass unsere
						Anwendung auch in Zukunft skalierbar bleibt. Das sind die GrÃ¼nde, warum wir Performance Tests
						durchfÃ¼hren.
				</section>
				<section>
					<h2>Performance-Testing Arten ğŸ‹ï¸ğŸ§˜ğŸš£ğŸƒ</h2>
					<img src="images/performance-tests-types.png" alt="Performance-Testing Arten" class="r-stretch">
					<aside class="notes">
						Performance-Tests umfassen verschiedene Testarten, darunter Lasttests, Stress-Tests und
						Ausdauer- oder Dauertests. Jede dieser Testarten zielt darauf ab, unterschiedliche
						Leistungsaspekte einer Anwendung zu bewerten. Zum Beispiel:

						- Lasttests simulieren eine typische Nutzerbelastung, um zu sehen, wie die Anwendung unter
						normalen Bedingungen funktioniert.
						- Stress-Tests erhÃ¶hen die Belastung schrittweise Ã¼ber das normale Niveau hinaus, um die Grenzen
						der Anwendung zu finden.
						- KapazitÃ¤ts-Tests gehen mit Absicht Ã¼ber die Grenzen der Anwendung hinaus, um zu sehen, wie sie
						scheitert.
						- Ausdauer-Tests prÃ¼fen die Anwendung auf ihre FÃ¤higkeit, Ã¼ber einen langen Zeitraum unter
						erwarteter Belastung zuverlÃ¤ssig zu funktionieren.

						Durch Performance-Tests kÃ¶nnen wir EngpÃ¤sse identifizieren, die Leistung optimieren und
						sicherstellen, dass unsere Anwendung auch unter Spitzenlast oder bei steigender Nutzerzahl
						zuverlÃ¤ssig funktioniert. Mit diesem grundlegenden VerstÃ¤ndnis von Performance-Tests kÃ¶nnen wir
						nun einen spezifischeren Blick auf Apache JMeter werfen und verstehen, wie es uns unterstÃ¼tzt,
						unsere Anwendungen zu testen.
					</aside>
				</section>
			</section>
			<section>
				<section>
					<h2>Apache JMeter ğŸª¶</h2>
					<ul>
						<li>Open Source</li>
						<li>Java basiert</li>
						<li>GUI und CLI</li>
						<li>Skalierbar</li>
						<li>Plugins</li>
					</ul>
					<aside class="notes">
						Apache JMeter ist ein mÃ¤chtiges Open-Source-Tool, das vorwiegend fÃ¼r Performance-Tests und
						Lasttests von Anwendungen eingesetzt wird. Entwickelt in Java, bietet JMeter eine flexible
						Plattform fÃ¼r die Bewertung der Leistung von Webanwendungen.

						JMeter kann sowohl Ã¼ber eine grafische BenutzeroberflÃ¤che (GUI) als auch Ã¼ber die
						Kommandozeilenschnittstelle (CLI) bedient zu werden. WÃ¤hrend die GUI insbesondere wÃ¤hrend der
						Testentwicklungsphase fÃ¼r ihre Benutzerfreundlichkeit und visuelle RÃ¼ckmeldung geschÃ¤tzt wird,
						ermÃ¶glicht die CLI einen effizienteren Betrieb in Testumgebungen, was besonders bei der
						Integration in CI/CD-Pipelines nÃ¼tzlich ist. Oder eben auch fÃ¼r eine Integration in
						Cloud-LÃ¶sungen wie Azure Load Testing. Wir haben es auch in einer eigenen cloud-basierten
						LasttestlÃ¶sung im Einsatz, QLoad.

						JMeter zeichnet sich durch seine Skalierbarkeit aus. Es kann auf einzelnen Workstations fÃ¼r
						einfache Testaufgaben eingesetzt werden, lÃ¤sst sich aber auch in groÃŸem Umfang fÃ¼r komplexe
						Lasttests verwenden, die mehrere Server umfassen kÃ¶nnen. Diese Skalierbarkeit macht es zu einem
						idealen Werkzeug fÃ¼r Unternehmen jeder GrÃ¶ÃŸe, um die Leistung ihrer Anwendungen unter
						verschiedenen Lastbedingungen zu bewerten.

						Ein weiteres wichtiges Merkmal von JMeter sind die zahlreichen verfÃ¼gbaren Plugins, die seine
						FunktionalitÃ¤t erweitern. Diese Plugins ermÃ¶glichen es den Benutzern, neue TestfÃ¤higkeiten
						hinzuzufÃ¼gen, die Anpassung von Berichten zu verbessern und die Integration mit anderen Tools
						und Plattformen zu vereinfachen. Obwohl JMeter bereits eine umfassende Palette an
						TestmÃ¶glichkeiten bietet, erlauben es diese Plugins, das Tool noch weiter an spezifische
						BedÃ¼rfnisse anzupassen. Die Entwicklung eigener Plugins ist ebenfalls mÃ¶glich, was die
						FlexibilitÃ¤t von JMeter zusÃ¤tzlich erhÃ¶ht.

						Insgesamt bietet Apache JMeter als ein vielseitiges, leistungsstarkes Tool fÃ¼r
						Performance-Testing und Lasttest eine robuste LÃ¶sung fÃ¼r Entwickler und
						QualitÃ¤tssicherungs-Teams. Seine Open-Source-Natur, gepaart mit umfangreicher Dokumentation und
						einer aktiven Community, macht es zu einer zugÃ¤nglichen und wertvollen Ressource fÃ¼r die
						Optimierung der Leistung von Webanwendungen und anderen Diensten.
					</aside>
				</section>
				<section>
					<h2>Web-Applikation testen ğŸŒ</h2>
					<ul>
						<li>HTTP Request</li>
						<li>Response Times</li>
					</ul>
					<aside class="notes">
						Schauen wir uns nun an, wie wir mit JMeter eine einfache Web-Applikation testen kÃ¶nnen. Dazu
						verwenden wir eine einfache Flask-App, die wir auf einem Azure Web App Service bereitstellen.
						Diese App hat nur eine einzige Route, die wir mit einem Parameter aufrufen kÃ¶nnen, um eine
						bestimmte Zeit zu warten. Das ist nÃ¼tzlich, um die Reaktionszeit der Anwendung zu testen.
						und dadurch eine Art Last-Szenario zu simulieren. Wir tun also so, als ob viele Benutzer auf
						diese Route zugreifen und die Anwendung dadurch unter Last steht und langsamer wird. Wir
						werden sehen, wie wir mit JMeter eine solche Last erzeugen und die Reaktionszeiten messen
						kÃ¶nnen.
					</aside>
				</section>
				<section>
					<pre class="r-stretch">
						<code data-trim data-noescape data-line-numbers="1-18|8-12">
							from flask import Flask, request
							import time

							app = Flask(__name__)

							@app.route('/')
							def hello():
								# Retrieve the 'sleep' parameter from the URL
								sleep_time = float(request.args.get('sleep', 0))
								
								# Introduce a delay based on the sleep_time value
								time.sleep(sleep_time / 1000)

								return f"Slept for {sleep_time} milli seconds."


							if __name__ == '__main__':
								app.run(host='0.0.0.0', port=80)
						</code>
					</pre>
					<br>
					<a href="https://qyterawebapp.azurewebsites.net/?sleep=2000" target="_blank">Open App ğŸ</a>
					<span class="videoTrigger" data-video-src="videos/webapp-jmeter.mp4">ğŸ¦</span>
					<aside class="notes">
						DieRoute der Web-Applikation ist sehr einfach. Sie nimmt einen Parameter 'sleep' entgegen, der
						die Zeit in Millisekunden angibt, die die Anwendung warten soll. Das ist nÃ¼tzlich, um die
						Reaktionszeit der Anwendung zu testen. Wir werden sehen, wie wir mit JMeter Requests an diese
						Route senden und die Reaktionszeiten messen kÃ¶nnen.
						Aber schauen wir uns JMeter hier einmal in Aktion an.
					</aside>
				</section>
				<section>
					<h2>JMeter skalieren âš–ï¸</h2>
					<img class="r-stretch" src="images/jmeter-controller-worker.png" alt="JMeter">
				</section>
			</section>
			<section>
				<section>
					<h2>Azure Load Testing ğŸ§ª</h2>
					<p class="fragment">â“â“â“</p>
					<aside class="notes">
						Kommen wir endlich zum Hauptthema, dem Azure Load Testing. Aber was ist das eigentlich?
						DafÃ¼r lese ich einfach mal die offizielle Dokumentation von Microsoft vor. Die ist ja oft
						ziemlich gut und auf den Punkt.
					</aside>
				</section>
				<section>
					Quelle: Microsoft Azure Dokumentation â›²ï¸
					<blockquote class="r-stretch">
						"Azure Load Testing ist ein vollstÃ¤ndig verwalteter Auslastungstestdienst, mit dem Sie eine hohe
						Auslastung generieren kÃ¶nnen. Der Dienst simuliert Datenverkehr fÃ¼r Ihre Anwendungen, unabhÃ¤ngig
						davon, wo sie gehostet werden. FachkrÃ¤fte in der Entwicklung und QualitÃ¤tssicherung sowie
						Tester*innen kÃ¶nnen damit die Leistung, Skalierbarkeit oder KapazitÃ¤t einer Anwendung
						optimieren."
					</blockquote>
				</section>
				<section>
					<blockquote class="r-stretch">
						"Erstellen Sie schnell einen Auslastungstest fÃ¼r Ihre Webanwendung mithilfe einer URL und ohne
						vorherige Kenntnisse von Testtools. Azure Load Testing abstrahiert KomplexitÃ¤t und
						Infrastruktur, um Ihre Auslastungstests nach MaÃŸ durchzufÃ¼hren."
					</blockquote>
				</section>
				<section>
					<blockquote class="r-stretch">
						"FÃ¼r komplexere Auslastungstestszenarien kÃ¶nnen Sie einen Auslastungstest erstellen, indem Sie
						ein vorhandenes Apache JMeter-Testskript, ein beliebtes Open-Source-Tool fÃ¼r Auslastung und
						Leistung, wiederverwenden. Ihr Testplan kann beispielsweise aus mehreren Anwendungsanforderungen
						bestehen, Sie mÃ¶chten Nicht-HTTP-Endpunkte aufrufen, oder Sie verwenden Eingabedaten und
						Parameter, um den Test dynamischer zu gestalten."
					</blockquote>
				</section>
				<section>
					<blockquote class="r-stretch">
						"Wenn Ihre Anwendung auf Azure gehostet wird, sammelt Azure Load Testing detaillierte
						Ressourcenmetriken, die Ihnen helfen, LeistungsengpÃ¤sse bei Ihren Azure-Anwendungskomponenten zu
						erkennen."
					</blockquote>
				</section>
				<section>
					<blockquote class="r-stretch">
						"Um Regressionen in der Anwendungsleistung frÃ¼hzeitig zu erfassen, fÃ¼gen Sie Ihren
						Auslastungstest zu Ihrem Continuous Integration und Continuous Deployment (CI/CD)-Workflow
						hinzu. Nutzen Sie die Kriterien fÃ¼r das Scheitern von Tests, um die QualitÃ¤tsanforderungen Ihrer
						Anwendung zu definieren und zu validieren."
					</blockquote>
				</section>
				<section data-background-gradient="linear-gradient(to bottom, black 50%, white 100%)">
					<h2>Vorteile ğŸš€</h2>
					<ul>
						<li>Cloud basiert: kein Know-How von Infrastruktur oder IaC benÃ¶tigt (SaaS)</li>
						<li>Einfache Tests ohne Tool-Know-How sind mÃ¶glich</li>
						<li>JMeter fÃ¼r komplexe Szenarien (skalierbar)</li>
						<li>integrierte Analyse-Werkzeuge</li>
						<li>Integration in Azure DevOps</li>
					</ul>
					<aside class="notes">
						Und jetzt das ganze nochmal zusammengefasst auf diese 5 Punkte:
						Der Dienst ist vollstÃ¤ndig in der Cloud gehostet, was bedeutet, dass
						kein spezifisches Know-how in Bezug auf Infrastruktur oder Infrastructure as Code (IaC)
						erforderlich ist. Es handelt sich um eine Software as a Service (SaaS)-LÃ¶sung, die einfach zu
						bedienen und zugÃ¤nglich ist.

						DarÃ¼ber hinaus ermÃ¶glicht Azure Load Testing es Testern, Lasttests fÃ¼r die Entwicklung und
						QulaitÃ¤tsicherung zu nutzen. Der Dienst abstrahiert die KomplexitÃ¤t und Infrastruktur, um
						Lasttests nach MaÃŸ durchzufÃ¼hren. Und Ergebnisse kÃ¶nnen in integrierten Analyse-Werkzeugen
						visualisiert und analysiert werden.
					</aside>
				</section>
				<section data-background-color="white">
					<h2>Architektur ğŸ›ï¸ğŸ›•</h2>
					<img class="r-stretch" src="images/cloud-performance-testing.png" alt="Azure Load Testing">
					<aside class="notes">
						Die Architektur von Azure Load Testing ist relativ einfach. ZunÃ¤chst muss ich mich entscheiden
						einen einfachen Test durchzufÃ¼hren oder einen komplexen. FÃ¼r den einfachen wird einfach nur eine
						Website aufgerufen. DafÃ¼r erzeugt Azure Load Testing automatisch selbst ein JMeter Script.
						Ansonsten muss ich selbst eins hochladen. Dieses JMeter Script wird dann auf mehrere Runner
						verteilt, die Anzahl kann ich selbst festlegen. Die Runner sind virtuelle Maschinen, die die
						Last auf die Anwendung, rechts, ausÃ¼ben, in dem sie jeweils das JMeter Script ausfÃ¼hren. Die
						Ergebnisse werden dann in Azure Monitor gespeichert und kÃ¶nnen im Azure Load Testing dashboard
						analysiert werden.
					</aside>
				</section>
				<section data-background-gradient="linear-gradient(to bottom, white 0, black 50%)">
					<h2>Kosten ğŸ¤‘</h2>
					<ul>
						<li>bis zu 100.000 virtuelle User sind mÃ¶glich</li>
						<li>$0,15 pro VUH (Virtual User Hour), ab 9950 VUH nur noch $0,075</li>
						<ul>
							<li>1.000 User * 1 Stunde = 150â‚¬</li>
							<li>10.000 User * 2 Stunde = 9950 * 0.15 + 10.050 * 0.075 = 2246,25</li>
						</ul>
					</ul>
					<aside class="notes">Bei Cloud-Diensten wird hÃ¤ufig auch die Frage nach den Kosten gestellt. Deshalb
						darf das auch in dieser PrÃ¤sentation nicht fehlen, auch wenn ich es nur erwÃ¤hnen will und nicht
						im Detail darauf eingehen werde. Aber ich finde es wichtig zu wissen.
						Also, die Kosten fÃ¼r Azure Load Testing sind relativ einfach zu verstehen. Es gibt eine
						Preisstaffelung, die sich an der Anzahl der virtuellen Benutzerstunden (VUH) orientiert. Bis zu
						9.950 VUH kostet eine Stunde 15 Cent pro VUH. Ab 9.950 VUH sinkt der Preis auf 7,5 Cent pro VUH.
						Das bedeutet, dass 1.000 virtuelle Benutzer, die eine Stunde lang eine Last auf eine Anwendung
						ausÃ¼ben, 150â‚¬ kosten. Bei 10.000 virtuellen Benutzern, die zwei Stunden lang eine Last auf eine
						Anwendung ausÃ¼ben, also 20.000 VUH, kostet das 2246,25â‚¬.
						Insgesamt kÃ¶nnen so bis zu 100.000 virtuelle Benutzer gleichzeitig auf eine Anwendung zugreifen.
					</aside>
				</section>
				<section>
					<h2>Hands-On ğŸ‘</h2>
					<ul>
						<li>Erstellung eines (einfachen) Tests</li>
						<li>Skalierung</li>
						<li>Monitoring</li>
					</ul>
					<span class="videoTrigger" data-video-src="videos/azure-load-testing.mp4">ğŸ¦</span>
					<aside class="notes">
						Und jetzt kommen wir zum spannenden Teil, dem Hands-On. Ich werde euch zeigen wie
						Azure Load Testing funktioniert. Wir testen wieder die bereits bestehende, einfache Python
						Anwendung. Nur dieses mal aus der Cloud. ZunÃ¤chst erstellen wir einen sehr einfachen Test, noch
						vÃ¶llig ohne JMeter, dann fÃ¼gen wir unser zuvor angeschautes JMeter Script hoch und fÃ¼hren es
						aus. AnschlieÃŸend schauen wir uns die Ergebnisse an und wie wir das Monitoring nutzen kÃ¶nnen.
					</aside>
				</section>
				<section>
					<h2>Einbindung in Azure DevOps Pipelines ğŸ”—</h2>
					<img src="images/pipeline.png" alt="Azure DevOps Pipeline" class="r-stretch">
					<span class="videoTrigger" data-video-src="videos/load-testing-with-azure-devops.mp4">ğŸ¦</span>
				</section>
				<section>
					<h2>AufrÃ¤umen ğŸ—‘ï¸</h2>
					<aside class="notes">
						Am Ende eines solchen Tests ist es wichtig, die Ressourcen wieder zu bereinigen. Das ist
						insbesondere in der Cloud wichtig, da sonst Kosten entstehen kÃ¶nnen. Ich habe hierfÃ¼r wieder ein
						Script vorbereitet, das ich jetzt einfach starte. Das kÃ¶nnt ihr in eurer Umgebung natÃ¼rlich
						genauso verwenden. Sollten die Tests dauerhaft oder kontinuierlich durchgefÃ¼hrt werden, kÃ¶nnen
						die Ressourcen auch bestehen bleiben. Was hiervon wirklich Kosten verursacht, wenn es nicht
						benutzt wird, mÃ¼sst ihr dann aber selbst Ã¼berprÃ¼fen.
				</section>
			</section>
			<section>
				<h2>Fazit ğŸ©»</h2>
				<ul>
					<li>Apache JMeter ist mÃ¤chtig</li>
					<li>Microsoft Azure Load Testing ist eine gute ErgÃ¤nzung</li>
					<li>Azure DevOps macht das Setup komplett</li>
				</ul>
				<aside class="notes">
					Und damit komme ich auch schon zum Ende meiner PrÃ¤sentation. Ich hoffe, ich konnte euch einen
					guten Einblick in das Thema Performancetesting mit Microsoft Azure Load Testing geben.
					Durchleuchten wir die Punkte noch einmal kurz: Ich denke,
					dass Apache JMeter ein mÃ¤chtiges Tool ist, das viele AnwendungsfÃ¤lle abdeckt. Aber es ist auch
					schÃ¶n zu sehen, dass es mit Azure Load Testing eine gute ErgÃ¤nzung gibt, die es ermÃ¶glicht, auch
					grÃ¶ÃŸere Lasttests einfach und effizient durchzufÃ¼hren. Und mit Azure DevOps ist das Setup dann
					komplett, um die Tests automatisiert und regelmÃ¤ÃŸig durchzufÃ¼hren. Vielen Dank fÃ¼r eure
					Aufmerksamkeit.
					Die restliche zeit kÃ¶nnen wir jetzt sehr gern fÃ¼r Fragen nutzen.
				</aside>
			</section>
			<section>
				<h2>Vielen Dank! ğŸ™</h2>
				<img src="images/qr-code.png" class="r-stretch">
			</section>
		</div>
	</div>

	<script src="dist/reveal.js"></script>
	<script src="plugin/notes/notes.js"></script>
	<script src="plugin/markdown/markdown.js"></script>
	<script src="plugin/highlight/highlight.js"></script>
	<script src="plugin/video-popup/video-popup.js"></script>
	<script src="plugin/pointer/pointer.js"></script>
	<script src="plugin/zoom/zoom.js"></script>
	<script src="plugin/search/search.js"></script>
	<script>
		Reveal.initialize({
			pointer: {
				key: "q", // key to enable pointer, default "q", not case-sensitive
				color: "red", // color of a cursor, default "red" any valid CSS color
				opacity: 0.8, // opacity of cursor, default 0.8
				pointerSize: 30, // pointer size in px, default 12
				alwaysVisible: false, // should pointer mode be always visible? default "false"
				tailLength: 10, // NOT IMPLEMENTED YET!!! how long the "tail" should be? default 10
			},
			slideNumber: 'c/t',
			hash: true,
			plugins: [RevealHighlight, RevealNotes, RevealPointer, RevealZoom, RevealSearch]
		});
	</script>
</body>

</html>